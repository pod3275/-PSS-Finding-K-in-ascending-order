# -PSS-Finding-K-in-ascending-order
 - 2016년 1학기 성균관대학교 이진규 교수님의 문제해결기법 수업, 1번째 과제  
 - 오름차순으로 되어있는 행렬에서 특정 k를 가장 적은 search로 찾기
 - 2016 1st semester Sungkyunkwan University Professor Jinkyu Lee's Problem Solving Strategies Class, 1st assignment
 - Finding a particular k in the ascending matrix with the least search
 
## 1. Problem
 - There is an N*N matrix. All elements in each row and column are sorted in an ascending order.
 
   (1)	Find a single k efficiently (minimum access of elements). If there are multiple k, you need to find **ANY SINGLE** k.
   
   (2)	Find all k efficiently (minimum access of elements). If there are multiple k, you need to find **ALL** k.
   
 - Example
   - Input : 5*5 matrix, k=7
   
     ![image](https://user-images.githubusercontent.com/26705935/41212049-4c6cd94a-6d76-11e8-9f4f-14c5d9f884e2.png)
   
   - Output : (2,1), (0,3)
   
 - Note
   - You need to implement cal_single() and cal_all() functions; do not modify and use main() and other parts. You can allow to modify cal_single() and cal_all() functions ONLY. (No global variables…)
   
## 2. Environment
 - language : C
 - IDE : Microsoft Visual studio 2017, [ideone](https://ideone.com/)
 
## 3. Problem solving strategy
### (1) Recursive algorithm
 - 재귀(Recursive)란, 어떠한 함수를 그 자체의 함수를 이용하여 정의하는 방법으로, 함수 내에 다시 함수를 call하는 것을 의미한다. N*N Matrix는 정사각형으로 되어 있고, 이를 여러 개의 작은 정사각형으로 나눈 후, 각각의 정사각형에서 주어진 원소 k를 찾을 수 있다고 생각하였다.
 
 - 아이디어
   - 작은 정사각형으로 나눌 때, 기준 점이 있어야 한다. 즉, 기준점을 중심으로 좌표의 사분 면과 같이 네 구역으로 나눌 수 있다. 기준 점은 N*N Matrix가 정사각형이기 때문에, 대각선의 중심으로 잡을 수 있다. 이 후에 한 구역에서 k를 검색하는 함수를 구현한다면, 처음에는 나누어진 네 구역에서, 그리고 각각의 구역에서 또 다시 네 구역으로 나누어 함수를 이용한다.
   
     ![image](https://user-images.githubusercontent.com/26705935/41212133-bd1b1634-6d76-11e8-9aae-53ff2c72106d.png)
     
 - 이점
   - 재귀적(Recursive) 방법을 이용한다면, 코드를 간편화 할 수 있다. 또한 기준이 되는 함수만 정확히 구현된다면, 예외적인 상황에서도 정확한 결과 값을 나타낼 것이다. 그리고 재귀적 방법은 문제를 가장 효율적으로 푸는 방법들 중 하나이다. (실제로 문제의 O(n)을 구할 때도, Divide-And-Conquer 와 Recursive Call을 이용하여 계산한다.)
 
 - 한계
   - 재귀적 방법으로 본 문제를 해결하는 과정에서 여러 한계를 느꼈다. 첫 번째로, N*N Matrix 자체는 정사각형이 맞지만, 이를 네 영역으로 나눌 때, 일정한 틀을 유지하지 못한다는 점이다. 특히 N이 홀수인 경우, 네 정사각형으로 나누기 위해선 한 개의 행 또는 열이 남고, N이 짝수인 경우, 정확한 중심이 되는 기준점을 잡기 어렵다. 물론 구역을 나누면서 N의 홀,짝에 따라 하나의 변을 버리거나, 중심과 가까운 점을 중심으로 잡는 등의 방법으로 정사각형 형태를 만들 수 있다. 하지만 여러 가지 경우를 생각해야 하므로, 일반적인 재귀적 방법과는 어긋난다.
   
   - 가장 크게 느낀 한계는 두 번째이다. 코드를 구현할 때, *call_single()*과 *call_all()* 함수 이외의 다른 함수를 만들지 못하는 규칙이 있다. 하나의 함수 내에서 다른 함수를 정의하는 것은 C 프로그래밍 상에서 불가능하기 때문에, 재귀 함수를 이용하기에는 큰 어려움이 있다고 판단하였다.

### (2) Random selection
 - N*N Matrix에 저장되는 원소들은 각 같은 행과 열에서 오름차순을 이룬다는 성질은 있지만, 결국 랜덤 하게 저장된다. 즉, 행렬 내의 원소들의 범위, 수의 종류 등은 전혀 알 수 없다. 때문에, 일반적인 N과 모든 수에 대해 문제를 해결할 수 있는, 일반적인 알고리즘을 기반으로 코드를 구현해야 한다. 기존 행렬 내의 수 배치가 랜덤 하다는 것에서 착안하여, 원소를 찾는 방법을 랜덤 함수를 이용하여 구현할 수 있다는 생각을 하였다.
 
 - 아이디어
   - 랜덤 함수(rand())는 현재 시각에 따라, 제한되지 않은 범위 내의 random한 수를 제공한다. 범위를 설정하기 위해서는 % (나머지) 기호를 이용한다. 랜덤 함수를 처음부터 이용하는 것은 항상 효율적인 값을 나타낼 수 없다. 그러므로, 원소 값을 access해야 하는 영역의 범위를 최대한 줄인다. N*N Matrix에서 대각선 위의 원소들((0,0)부터)을 비교하여, k와 가장 근접하고, k보다 큰 원소를 찾는다. 이 원소를 중심으로 왼쪽 위의 영역 내에는 k가 없다는 것을 알 수 있다. 이는 모든 행과 열이 오름차순으로 정리되어 있기 때문이다.
   - 나머지 세 구역 내의 원소들에 대해서 rand() % LENGTH 로 임의의 원소를 뽑아 k와 비교한다. 만일 k라면, 좌표를 따로 저장한다. k와 같지 않다면 저장하지 않고, 그 원소의 왼쪽에 위치하는 원소들을 검색 대상에서 제외시킨다. 한 번 검사된 원소는 따로 표시하여, 중복 검사를 막는다. 이와 같은 방법으로 나머지 세 구역의 원소들을 검사한다.
   
     ![image](https://user-images.githubusercontent.com/26705935/41212265-a145fcc0-6d77-11e8-8afa-16480e6bc9d9.png)
   
 - 이점
   - 코드를 가장 간단하게 구현할 수 있다는 장점이 있다. 다양한 경우를 생각하지 않아도 일반적이고 정확한 결과 값을 나타낼 것이다. 또한 제외한 구역이 존재하기 때문에, 모든 수를 검사하는 방법(두 번의 for문을 이용)에 비하여 적은 access 수로 문제를 해결할 수 있다.
   
 - 한계
   - 한계는 뚜렷하다. 결국 이 방법은 모든 수를 검사하는 경우이기 때문에, 효율적인 부분에서 큰 문제가 발생한다. 본 문제의 핵심은 “얼마나 효율적으로, 정확한 답을 찾아내는가” 이다. 이 아이디어는 정확한 답을 찾아낼 수는 있지만, 가장 효율적인 알고리즘이라고 말할 수는 없다.

### (3) Zone allocation and base point search method.
 - N*N Matrix의 대각선을 이용하여 기준점을 잡고, 네 구역으로 나누어 하나의 구역(왼쪽 위 구역)을 검색에서 제외시키는 방법이 일단 효율적이라고 생각하였다. 이를 바탕으로 보다 일반적이고 효율적으로 나머지 세 구역을 검색하는 알고리즘을 생각하였다. 특히 문제에서 가장 중요한 요소인 같은 행과 열에서 원소들이 오름차순으로 정리되어 있다는 점을 고려하였다.
 
 - 아이디어
   - (0,0)에서 시작하여 대각선을 따라 내려오면서, 처음으로 k보다 크거나 같은 수가 나타나는 좌표를 기준점으로 잡았다. 경우를 크게 두 가지로 나눈다.
   
   - 만일, 기준점이 k와 같다면, 오른쪽 아래에도 k와 같은 수의 원소가 있을 가능성이 있다. 이는 같은 행과 열에서 중복되는 값을 갖는 원소가 존재할 수 있기 때문이다. 오른쪽 아래의 원소들은 다음과 같은 방법으로 조사한다.
     - 기준점에서 오른쪽 방향으로, k보다 큰 수가 나타나는 원소까지 같은 행의 원소들을 k와 비교한다. 만일 원소의 값이 k보다 크다면, 그 원소의 오른쪽에 위치하는 모든 원소들은 k보다 크기 때문에 비교할 필요가 없다. 비교 중에 k와 같은 원소가 있다면, 좌표를 저장한다.
     - 다음 (아래의) 행에서 같은 방법을 반복하여 비교한다. 만일 밑의 행의 첫 번째 원소가 k보다 크다면, 그 아래 행과 오른쪽 열에 존재하는 모든 원소들은 k보다 크기 때문에 비교할 필요가 없다. 비교 중에 k와 같은 원소가 있다면, 따로 좌표를 저장한다.
   - 만일, 기준점이 k와 같지 않다면 기준점 오른쪽 아래의 모든 원소들은 k보다 크다. 따라서 조사할 필요가 없다.
   - 이후, 기준점의 오른쪽 위 구역의 원소들을 조사한다. 이는 기준점이 k와 같던 다르던, 반드시 행해야 한다. 오른쪽 위 구역의 원소들은 다음과 같은 방법으로 조사한다.
     - 기준점의 열에서 위쪽 방향으로 k보다 작거나 같은 원소가 나타날 때까지 조사한다. 만일 원소의 값이 k보다 크다면, 그 원소의 오른쪽 행에 위치하는 모든 원소들은 k보다 크기 때문에 비교할 필요가 없다.
     - k보다 작거나 같은 원소가 나타난다면, 그 원소의 오른쪽 방향으로, k보다 큰 원소가 나타날 때까지 같은 행의 원소들을 비교한다. 만일 원소의 값이 k보다 크다면, 그 오른쪽에 위치하는 모든 원소들은 k보다 크기 때문에 비교할 필요가 없다. 비교 중에 k와 같은 원소가 있다면, 좌표를 따로 저장한다.
   - 마지막으로, 기준점의 왼쪽 아래 구역의 원소들을 다음과 같은 방법으로 조사한다.
     - 기준점의 행에서 왼쪽으로 가면서 k보다 작은 원소가 나타날 때까지 조사한다. 만일 원소의 값이 k보다 크다면, 그 원소의 아래 열에 위치하는 모든 원소들은 조사할 필요가 없다.
     - k보다 작거나 같은 원소가 나타난다면, 그 원소의 아래 방향으로, k보다 큰 원소가 나타날 때까지 같은 열의 원소들을 비교한다. 만일 원소의 값이 k보다 크다면, 그 아래에 위치하는 모든 원소들은 k보다 크기 때문에 비교할 필요가 없다. 비교 중에 k와 같은 원소가 있다면, 좌표를 따로 저장한다.

 - 이점
   - 가장 큰 특징은 다른 아이디어들보다 더욱 효율적이라는 것이다. 처음 큰 정사각형을 네 구역으로 나눈 후, 한 구역을 조사할 필요가 없도록 하였다. 또한, 나머지 세 구역에서의 조사도 모든 원소를 조사하지는 않는다. 같은 행 또는 열의 원소들은 오름차순이라는 성질을 가지고 있다. k보다 큰 값이 나타난 경우에서 같은 행 또는 열에 위치한 원소들을 더 이상 비교할 필요가 없다는 점을 착안하여, 비교 횟수를 줄였다.
   - 뿐만 아니라 모든 구역에서의 꼼꼼한 비교가 이루어지기 때문에, 예외적인 상황 혹은 극단적인 상황에 대해서도 정확한 결과 값을 도출할 수 있다.
   
 - 한계
   - 네 구역으로 나눈 후 한 구역을 조사하지 않고 나머지 세 구역을 조사한다. 세 구역을 조사하는 과정에서, 오름차순의 성질을 최대한 활용하여 원소들을 검사한다. 하지만 조사하는 방법은 역시 각각의 원소의 크기 비교 및 k와의 등호로 하나하나 조사한다. 조사하는 방법에서 다른 아이디어를 복합하여 새로운 알고리즘을 짠다면 (예를 들어, 조사하는 경우에서 재귀적 방법을 이용하여 여러 직사각형의 꼴에서도 조사할 수 있도록 만들 수 있다.) 더욱 효율적으로 결과 값을 도출하는 프로그램을 작성할 수도 있다. 일단 직접 생각한 여러 가지 아이디어들 중에서 가장 효율적이라고 생각하여 본 아이디어를 선택하였지만,더욱 효율적이고 일반적으로 결과를 도출하는 다른 알고리즘이 분명히 있을 것이라 생각한다.
      
## 4. Result
 - 이 프로그램이 정확한 결과값을 도출하는지를 알아보기 위해서 간단한 10 * 10 matrix를 임의로 만들었다. 아래는 프로그램 작동 확인을 위해 임의적으로 만든 10*10 matrix이다.
  
   ![image](https://user-images.githubusercontent.com/26705935/41212545-bfad7cfe-6d79-11e8-9f4f-4d798377bd3c.png)
  
 - 이에 대한 결과는 아래와 같다. 다음은 k에 24를 대입하고 프로그램을 실행한 결과이다. call_all() 함수의 결과를 보면 예시의 matrix 내 24를 갖는 모든 원소들의 좌표를 정확하게 출력했다는 것을 알 수 있다. count는 61로, 최대 100의 count를 할 수 있는 환경에서 많이 줄였다고 생각할 수 있다. 또한 call_single()의 함수의 count수는 9로, 매우 효율적으로 결과를 도출한 것이라고 볼 수 있다.
 
   ![image](https://user-images.githubusercontent.com/26705935/41212650-6e5e0e12-6d7a-11e8-990a-8f389dc8c862.png)
   
 - 다음은 k에 13을 대입하고 프로그램을 실행한 결과이다. 예시의 matrix 내에는 13을 갖는 원소는 존재하지 않는다. 프로그램 실행 결과, 존재하지 않는 원소까지 정확하게 포착하여 아무것도 출력하지 않는 결과를 나타내었다. count 수도 어느 정도 존재하는 것은 프로그램 실행 중의 오류로 인해 아무것도 출력하지 않은 것은 아님을 알려준다.
 
   ![image](https://user-images.githubusercontent.com/26705935/41212655-75861626-6d7a-11e8-888b-54be11147a76.png)
   
 ## 5. Future work
 - 더욱 효율적으로 찾는 알고리즘을 연구해야 한다. 어떤 범위 내의 숫자의 중간값을 활용하여 특정 숫자를 찾는 것이 수업 내에서 가장 효율적인 알고리즘이었다.
